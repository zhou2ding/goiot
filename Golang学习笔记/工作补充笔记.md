# CGo调用c/c++静态库

> Cgo封装了#cgo伪c文件，参数CFLAGS用来传入编译选项，LDFLAGS来传入链接选项，这个用来调用非c标准的第三方c库
>
> Cgo是不可以直接调用c++的代码的。所以如果需要调用，必须在C的层面上进行一次封装，Go调C，C调C++

## 前言

- windows中`.dll` `.lib`区别
  - `lib`是和`dll`对应的。`lib`是静态链接库的库文件，`dll`是动态链接库的库文件
  - 所谓静态就是`link`的时候把里面需要的东西抽取出来安排到你的`exe`文件中，以后运行你的`exe`的时候不再需要`lib`
  - 所谓动态就是`exe`运行的时候依赖于`dll`里面提供的功能，没有这个`dll`，你的`exe`无法运行
  - 源代码和最终目标文件中过渡的就是中间代码`obj`，一个`exe`需要很多的`cpp`文件生成，而编译器一次只能编译一个`cpp`文件。这样编译器编译好一个`cpp`以后会将其编译成`obj`，当所有必须要的`cpp`都编译成`obj`以后，再统一`link`成所需要的`exe`

- linux中`.o` `.a` `.so`区别
  - `.o,`是目标文件,相当于windows中的`.obj`文件 
  - `.a`为静态库,是好多个`.o`合在一起,用于静态连接 
  - `.so`为共享库,是`shared object`,用于动态连接的,相当于`windows`下的`dll`

## 步骤

1. 目录结构

   ```bash
   ├─lib
   │  │─head.h
   │  │─test.a
   ├─cmd
   │  ├─mycgo
   │  │  │─main.go
   ```

2. 编译链接库

   - `linux`：编译成动态库`.so`或``.a`

     ```bash
     # .a
     gcc -c test.c
     ar -rv libtest.a test.o	#必须是libxxx.a
     # .so
     gcc -c -fPIC -o test.o test.c
     gcc -shared -o libtest.so test.o	#必须是libxxx.so
     ```

   - `windows`：编译成`.lib`或`.dll`

3. `Go`代码中引用链接库

   - linux

     - `CFLAGS`中的`-I`（大写的i）参数表示`.h`头文件所在的路径
     - `LDFLAGS`中的`-L`(大写)表示`so`文件所在的路径，`-l`(小写的L)表示指定该路径下的库名称，比如要使用`libtest.so`，则只需用`-ltest` （省略了`libtest.so`中的`lib`和`.so`字符）

     ```go
     // +build linux
     package main
     
     /*
     #cgo CFLAGS: -I../../lib
     #cgo LDFLAGS: -L../../lib -ltest
     #include "head.h"
     #include <stdlib.h>
     */
     import "C"	//这里可看作封装的伪包C, 这条语句要紧挨着上面的注释块，不可在它俩之间间隔空行
     
     import "fmt"
     
     func main() {
         C.func1()							// head.h头文件中提供的函数
         vcStr := C.CString("abc")			// C包提供的函数，调用它的话<stdlib.h>必须引用
         defer C.free(unsafe.Pointer(vcStr))	// 同上
         
         fmt.Println("Hello cgo!")
     }
     ```

   - windows

     ```go
     // +build windows
     
     package license
     
     /*
     #include <stdio.h>
     #include <stdlib.h>
     */
     import "C"
     
     import "fmt"
     
     func main() {
         handle, err := syscall.LoadDLL("../../lib/test.dll")
         if err != nil {
     		return false, err
     	}
     	func1, err := handle.FindProc("func1")
     	if err != nil {
     		return false, err
     	}
         func1.Call()
         
         fmt.Println("Hello cgo!")
     }
     ```

## 类型转换

> C中拥有的类型都可以以C.type的形式提供给go进行传参时的转换

- 基本类型转换

  | C类型         | CGo类型 | Go类型 |
  | ------------- | ------- | ------ |
  | char |  C.char |  byte |
  | signed char |  C.schar |  int8 |
  | unsigned char |  C.uchar |  uint8 |
  | short int |  C.short |  int16 |
  | short unsigned int |  C.ushort |  uint16 |
  | int |  C.int |  int |
  | unsigned int |  C.uint |  uint32 |
  | long int |  C.long |  int32 or int64 |
  | long unsigned int |  C.ulong |  uint32 or uint64 |
  | long long int |  C.longlong |  int64 |
  | long long unsigned int |  C.ulonglong |  uint64 |
  | float |  C.float |  float32 |
  | double |  C.double |  float64 |
  | wchar_t |  C.wchar_t  ||
  | void * | unsafe.Pointer |unsafe.Pointer(anyType)|

- 指针类型转换

  > 如果需要传递指针类型，需要先进行unsafe.Pointer的转化，再进行强转

  ```go
  package main
  
  /*
  #cgo CFLAGS: -I../../lib
  #cgo LDFLAGS: -L../../lib -ltest
  */
  import "C"
  
  func main() {
      /**
       * 由于slice自身是一个结构体，我们需要传递的只是其中的data部分，所以需要取数据部分的首地址
       * 还有个地方需要注意，由于我们传递的是数据段的首地址，所以这段数据并没有结束符，所以需要手动添加结束符，或者同时传递slice的真实长度，避免内存越界
      */
      b := []byte("hello world")
  	tmp1 := (*C.char)(unsafe.Pointer(&b[0]))	// 将[]byte作为char*传递
      
      var u uint32
      tmp2 := (*C.uint)(unsafe.Pointer(&u))
      
      vcStr := C.CString("abc")
      tmp3 := C.my_code_t(unsafe.Pointer(vcStr)) // 此处无需取地址
  }
  ```
  
  ```c
  // test.h
  typedef const void *my_code_t;
  ```

# Linux定时任务

## 用法

- 添加定时任务的方式

  - `crontab`命令

    ```bash
    crontab [-u username]	#省略用户表表示操作当前用户的crontab
        -e      (编辑定时任务表)	#我们用crontab -e进入当前用户的工作表编辑，是常见的vim界面，每行是一条命令
        -l      (列出定时任务表里的命令)
        -r      (删除当前用户的定时任务表，即删除通过crontab -e指定的所有定时任务)
    ```

  - 修改`/ect/crontab`(可以参考文件中的例子)，`crond`会每分钟读取一次此配置文件，如果有变化就会`reload`，日志可以看`/var/log/cron.log`

- `cron`表达式

  ```bash
  # * 取值范围内的所有数字
  #/ 每过多少个数字
  # - 从X到Z
  # ，散列数字
  ```

  ![image-20220514161100898](E:\study\studygo\Golang学习笔记\工作补充笔记.assets\image-20220514161100898.png)

## 实例

实例1：每1分钟执行一次myCommand

```
* * * * * myCommand
```

实例2：每小时的第3和第15分钟执行

```
3,15 * * * * myCommand
```

实例3：在上午8点到11点的第3和第15分钟执行

```
3,15 8-11 * * * myCommand
```

实例4：每隔两天的上午8点到11点的第3和第15分钟执行

```
3,15 8-11 */2  *  * myCommand
```

实例5：每周一上午8点到11点的第3和第15分钟执行

```
3,15 8-11 * * 1 myCommand
```

实例6：每晚的21:30重启smb

```
30 21 * * * /etc/init.d/smb restart
```

实例7：每月1、10、22日的4 : 45重启smb

```
45 4 1,10,22 * * /etc/init.d/smb restart
```

实例8：每周六、周日的1 : 10重启smb

```
10 1 * * 6,0 /etc/init.d/smb restart
```

实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb

```
0,30 18-23 * * * /etc/init.d/smb restart
```

实例10：每星期六的晚上11 : 00 pm重启smb

```
0 23 * * 6 /etc/init.d/smb restart
```

实例11：每一小时重启smb

```
0 */1 * * * /etc/init.d/smb restart
```

实例12：晚上11点到早上7点之间，每隔一小时重启smb

```
0 23-7/1 * * * /etc/init.d/smb restart
```

# curl

# RESTful

# websocket

# 数据库备份
