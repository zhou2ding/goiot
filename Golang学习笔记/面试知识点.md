# 网络

## 基础篇

### TCP/IP网络模型

- **应用层**：只专注于为用户提供应用功能，不关心数据如何传输，如HTTP、FTP、Telnet、DNS、SMTP等，工作在OS中的用户态。

- **传输层**：为应用层提供网络支持，分为TCP和UDP。

  - TCP：大部分应用使用的传输层协议，有UDP没有的流量控制、超时重传、拥塞控制等特性，确保数据可靠地传输给对方。

    - **分段**：传输层的数据包大小超过MSS(TCP最大报文段长度)就要对数据分段(**TCP Segment**)，若有分段丢失或损坏，重传即可。

    - **端口**：一台设备上有多个应用接收或传输数据，用端口号进行区分，传输层的报文中携带端口号。

      > 浏览器中的每个标签栏都是独立的进程，OS会给它们分配临时的端口号。

  - UDP：比TCP简单，只负责发送数据包，不保证能否抵达，实时性更好，传输效率也高。把TCP的特性在应用层实现则能让UDP实现可靠传输。

- **网络层**：实际将数据从一个设备传输到另一个设备的分层，进行路径和节点的选择。最常用的是IP协议，有**寻址**和**路由**功能。

  - IP包：把传输层的报文作为数据部分，再加上IP包头组成IP包。如果包的大小超过MTU(一般1500Bytes)会**再次分片**（每个分片都有各自的包头）。

    ![img](面试知识点.assets/12.jpg)

  - IP地址：对于IPv4协议，IP地址分4段32位，每段8位，由**网络号**和**主机号**组成。

    > 子网掩码为0-32，每个数字表示IPv4格式的地址从最左边开始有几个1
    >
    > 如16 --> 255.255.0.0(11111111.11111111.00000000.00000000)

    - 网络号标识该地址属于哪个子网，由**子网掩码**和地址进行**与运算**得到。
    - 主机号标识同一子网下的不同主机，由**子网掩码取反**后和地址进行**与运算**得到。
    - 寻址过程中先匹配网络号找到子网，再匹配主机号找对应的主机。
    - 实际网络是通过很多网关、路由器、交换机等众多设备连接的，因此数据包到达一个网络节点后，通过**路由**算法决定下一步走哪条路径。

  - ==IP协议的寻址作用是告诉我们去往目的地该朝哪个方向走，即导航；路由则是根据下一个目的（网络节点）地选择路径，即操作方向盘。==

- **网络接口层**：为网络层提供链路级别传输的服务，负责在以太网、WiFi等底层网络上发送数据包，工作在网卡这个层次，使用MAC地址标识网络上的设备。

  - MAC地址：网络接口层给IP报文加上MAC头部(包含接收方和发送方的MAC地址)并封装成数据帧(Data frame)，然后发送到网络上，其中接收方的MAC地址通过ARP协议获取，通过匹配MAC地址在以太网中通讯。

  > 以太网就是在局域网内，把附件的设备连接起来，使它们之间可以通讯的技术。

**总结**

TCP/IP 网络通常是由上到下分成 4 层，分别是应用层，传输层，网络层和网络接口层。

![img](面试知识点.assets/tcpip参考模型.drawio.png)

HTTP的传输单位是消息或报文（message），TCP的传输单位是段（segment），IP的传输单位是包（packet），网络接口层的传输单位是帧（frame）。

> HTTP也可以分割报文：使用分块传输编码技术把报文的主体分块后发送，客户端通过接收数据块并解码后逐步显示页面。

![img](面试知识点.assets/封装.png)

### 协议栈

应用程序（如浏览器）通过调用socket库，委托OS的协议栈工作。OS的协议栈包括传输层的TCP和UDP，网络层的IP、ICMP、ARP，协议栈的下层是网卡驱动程序和物理硬件网卡

![img](面试知识点.assets/7.jpg)

### 打开网页全过程

> 每往下走一层，就会把上一层的报文作为本层报文的数据部分，再加上本层的报文头。

#### HTTP

浏览器先解析URL以确定Web服务器的域名和资源的目录，解析完后根据这些信息生成HTTP请求消息。

> HTTP详解参考《HTTP笔记.md》

#### DNS

发送数据前，需要查询服务器域名对应的IP地址，DNS服务器专门保存了域名和IP的对应关系

- 层级：域名用`.`分割成不同的层级，**越靠右层级越高**。

- 树状结构：域名的层级关系类似一个树状结构。

  > 根域：域名最右边的`.`（如`www.server.com.`）。根域服务器的信息保存在所有DNS服务器中，因此客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。

  ![image-20221205192456248](面试知识点.assets/image-20221205192456248.png)

- 解析流程

  1. 浏览器查看自身有没有缓存域名的IP地址，有则返回，没有则下一步
  2. OS查看有没有缓存，有则返回，没有则下一步
  3. hosts文件中有则返回，没有则下一步
  4. 客户端发出DNS请求给本地DNS服务器（客户端的TCP/IP设置中填写的DNS服务器地址）
  5. 本地DNS服务器收到请求后在缓存表格中查找，找到则返回IP地址，找不到则将请求发给根域名服务器
  6. 根DNS收到本地DNS请求后，根据顶级域名的不同把对应的顶级域服务器的地址回给本地DNS服务器
  7. 本地DNS收到顶级域服务器地址后向其发起请求
  8. 顶级域服务器收到后根据权威域名的不同把对应的权威域服务器的地址回给本地DNS服务器
  9. 权威DNS服务器负责解析域名，将查到的IP地址回给本地DNS
  10. 本地DNS把IP地址回给客户端

  ![img](面试知识点.assets/6.jpg)

#### TCP

- TCP头部主要包括
  - **源端口号**和**目的端口号**。
  - **包的序号**：解决包乱序的问题。
  - **确认号**：确认对方是否收到，没有则重发，直到送达，解决丢包问题。
  - **状态位**：`SYN`是发起连接，`ACK`是回复，`RST`是重新连接，`FIN`是结束连接。带状态位的包发送后，会引起双方状态的变更。
  - **窗口大小**：通信双方各声明一个窗口（缓存大小）标识自己当前的处理能力，进行**流量控制**。

- TCP传输数据前要**三次握手**建立连接，保证**双方都有发送和接收的能力**。

  > 所谓的连接，只是双方计算机里维护一个状态机，建立连接过程中，双方的状态发生变化

  1. 客户端和服务端都处于`CLOSED`状态。
  2. 服务端主动监听某个端口，处于`LISTEN`状态。
  3. 客户端主动发起连接`SYN`，处于`SYN-SENT`状态。
  4. 服务端收到发起的连接，返回`SYN`，并`ACK`客户端的`SYN`，处于`SYN-RCVD`状态。
  5. 客户端收到服务端的`SYN`和`ACK`后，发送对服务端的`SYN`的`ACK`，处于`ESTABLISHED`状态。
  6. 服务端收到客户端的`ACK`后，处于`ESTABLISHED`状态。

  ![img](面试知识点.assets/TCP三次握手.drawio.png)

- TCP分割数据

  > MTU：一个网络包的最大长度，以太网中一般1500Bytes；MSS：除去IP和TCP头部后，一个网络包所能容纳的TCP数据的最大长度。

  - HTTP消息超过了`MSS`长度时，TCP会把数据拆解成一块块的数据。
  - 拆分出来的每块数据都放进单独的网络包中，即每块都有TCP头信息。

  ![img](面试知识点.assets/12.jpg)

#### IP

- IP头部主要包括
  - **源IP地址**：客户端若存在多个网卡，则由目标IP地址和各个网卡的`Genmask`进行**与运算**，得到的结果与网卡的`Destination`匹配，相同则使用此网卡作为源IP（使用`ip addr show 网卡名称`命令查看）都匹配不到则使用默认网关（`Genmask`和`Destination`都是`0.0.0.0`），后续把包发给路由器（`Flags中有G标识的`，`GateWay`是路由器的IP地址）。详解参考[route命令用法](https://segmentfault.com/a/1190000039410494)。
  - **目标IP地址**：由DNS解析获得。
  - **协议号**（`06`表示TCP）。

#### MAC

- MAC头部主要包括

  - **接收方MAC地址**：通过ARP协议，先查询ARP缓存中是否有目标IP的MAC地址，没有在以太网中以广播的形式获取目标IP的MAC地址。

    > 获取到的一般都是网络路径中下一个节点（如网卡、路由器等节点）的MAC地址，到达节点后先去掉包中的MAC地址，再获取下一个节点的MAC地址，通过不断地转发到达目的地。

  - **发送方MAC地址**：写在网卡的ROM中（只读存储器，只能读出无法写入信息，信息一旦写入后就固定下来，即使切断电源，信息也不会丢失）。

  - **协议类型**：在TCP/IP通信里，MAC头部中的协议类型只有`0800`（IP协议）和`0806`（ARP协议）。

![img](面试知识点.assets/21.jpg)

#### 网卡

- **网卡驱动程序**获取网络包后
  1. 核对接收方MAC地址，判断是否是发给自己的，是则将其复制到网卡内的缓存区中，不是则丢弃。
  2. 在开头加上**报头**和**起始帧分界符。**
  3. 在末尾加上**FCS**（用于检测错误的校验帧序列）。

- 网卡驱动程序控制**网卡**，将网络包这种**数字信号转换为电信号**，在网线上发出去。

![img](面试知识点.assets/数据包.drawio.png)

#### 交换机

> 现在家里的路由器其实有了交换机的功能了。

交换机将网络包**原样**转发到目的地，工作在**MAC层**，称为**二层网络设备**。交换机不核对接收方的MAC地址，而是接收所有的包，因此交换机的端口不具有MAC地址。

1. 电信号到达网线接口，交换价中的模块接收后转换成数字信号。

2. 通过`FCS`校验错误，没错则放入缓冲区。

3. 查询包的接收方MAC地址是否在地址表中，在则发送到相应的端口中，不在则转发到除了源端口之外的所有端口上。目标设备收到包后会作出响应，交换机就会将它的MAC地址写入地址表，下次就不需要广播了。

   > 交换机的MAC地址表保存了设备的MAC地址和该设备连接在交换机的哪个端口上。
   >
   > 若接收方MAC地址是广播地址，则直接转发到除源端口的所有端口。MAC地址FF:FF:FF:FF:FF:FF和IP地址255.255.255.255属于广播地址。

4. 数据包离开交换机到达路由器后，就准备离开好离开子网了。

#### 路由器

路由器基于IP设计，称为**三层网络设备**，各个端口都具有MAC地址和IP地址。

1. 电信号到达网线接口，路由器中的模块接收后将电信号转成数字信号并通过`FCS`进行校验。
2. 核对接收方MAC地址判断是否是发给自己的，是则放入缓冲区，不是则丢弃。
3. 去掉包的MAC头部。
4. 根据IP头部的目标IP地址，查找路由表得到转发目标。
5. 若转发目标的网关是IP地址，则此IP就是要转发的目标地址，继续转发；若网关是空，则说明到达目的地了。
6. 继续转发时，也是根据上一步获得的IP通过ARP查询接收方的MAC地址，加上MAC包头后转成电信号发送出去，通过交换机到达下一个路由器。

> 在网络包传输的过程中，**源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址**，因为需要 MAC 地址在以太网内进行**两个设备**之间的包传输。

#### 目的地服务器

数据包到达服务器后，服务器会查看MAC头部判断是否是发给自己的，是就接收，然后一层一层去掉头部。

![img](面试知识点.assets/25.jpg)

### Linux网络

#### 网络模型

国际标准化组织制定了7层OSI网络模型，分别是应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。

但OSI模型太复杂，也只是概念上的分成，比较常见且使用的是四层模型，即TCP/IP网络模型，Linux就是按照这套模型实现网络协议栈的。

#### 网络协议栈

网络模型的每一层都会对数据包进行封装，即添加各自的协议头，网络包的大小就会增大。以太网中规定MTU是1500Bytes，即单次传输的最大IP包的大小。网络包超过MTU的大小后就会分片，所以MTU越小，需要的分片就越多，网络的吞吐能力就越差。

Linux的网络协议栈如下图

![img](面试知识点.assets/协议栈.png)

Linux接收网络包流程

Linux发送网络包流程

## HTTP篇

![image-20221207164658443](面试知识点.assets/image-20221207164658443.png)

请求行：`方法 URI HTTP版本`；响应行：`HTTP版本 状态码 原因短语`

### 常见面试题

- HTTP是什么？

  > HTTP是超文本传输协议，HyperText Transfer Protocol。HTTP是一个在计算机世界里专门在**两点之间传输**文字、图片、音频、视频等**超文本数据**的**约定和规范**。


- HTTP常见的状态码有哪些？

  > - 1xx属于**提示信息**，是协议处理中的一种**中间状态**，还需要后续的操作，实际用的较少。
  >
  > - 2xx表示服务器**成功**处理了客户端的请求。
  >
  >   - `200 OK`表示一切正常，如果是非`HEAD`请求，响应都会有body数据。
  >   - `204 No Centent`含义和`200 OK`相同，但响应没有body数据。
  >   - `206 Partial Content`用于HTTP分块下载或断点续传，表示body数据只是资源的一部分，也表示成功。
  >
  > - 3xx表示客户端请求的资源发生了变动，需要客户端用新的URL重新发送请求获取资源，即**重定向**。
  >
  >   - `301 Moved Permanently`表示永久重定向，说明请求的资源已经不在了需要改用新的URL。
  >
  >   - `302 Found`、`307 Temporay Redirect`表示临时重定向，说明请求的资源还在，但暂时需要用另一个URL访问。
  >
  >     301、302、307都会在响应头里使用`Location`字段，指明要跳转的URL，浏览器会自动重新定向新的URL。
  >
  >   - `304 Not Modified`不具有跳转的含义，表示资源未修改，重定向已存在的缓存文件，告诉客户端可以继续使用缓存资源，用于缓存控制，称为缓存重定向。
  >
  > - 4xx表示客户端发送的**报文有误**，服务器无法处理。
  >
  >   - `400 Bad Request`表示客户端请求的报文有误，但只是个笼统的错误码。
  >   - `401 Unauthorised`表示认证失败。
  >   - `403 Forbidden`表示服务器禁止访问资源，并非客户端的请求出错。
  >   - `404 Not Found`表示请求的资源在服务器上未找到。
  >   - `405 Not Allowed`表示对于请求的资源，不允许使用请求行中指定的方法。
  >
  > - 5xx表示客户端的请求报文正确，但**服务器处理时内部发生了错误**。
  >
  >   - `500 Internal Server Error`表示服务器发生了错误，与400类似是个笼统的错误。
  >   - `501 Not Implemented`表示客户端请求的功能还不支持。
  >   - `502 Bad Gateway`表示访问服务器时网关或代理出现了错误。
  >   - `503 Service Unavailable`表示服务器无法响应客户端。

- HTTP常见首部字段有哪些？

  > - *Host*：客户端发送请求时，指定服务器的域名。
  > - *Content-Length*：服务器返回响应时，表示响应资源的数据长度。HTTP通过设置`CRLF`作为报文首部的边界，通过`Content-Length`字段作为报文主体的边界，以此解决TCP的粘包问题。
  > - *Connection*：用于客户端要求服务器使用HTTP长连接机制以便其他请求复用。HTTP/1.1的默认连接都是长连接，但为了兼容老版本，需要指定`Connection: Keep-Alive`。开启长连接后，只要没有一端提出断开连接，TCP连接就不会断开，客户端发送另一个请求时，会使用同一个TCP连接。当然如果一段时间内没有任何数据交互，服务端会主动断开这个连接。（注意：TCP Keepalive和HTTP Keep-Alive不一样）
  > - *Content-Type*：告诉客户端本次响应的数据是什么格式。`Content-Type: text/html; charset=utf-8`说明返回的数据是网页，且是utf-8编码。
  > - *Accept*：客户端请求时声明自己可以接受哪些数据格式。`Accept: */*`声明自己可以接受任何格式的数据。
  > - *Content-Encoding*：说明返回的数据用了什么压缩方法。eg：`Content-Encoding: gzip`。
  > - *Accept-Encoding*：客户端请求时声明可以接受哪些压缩方法。eg：`Accept-Encoding: gzip, deflate`。

- GET、POST、PUT、PATCH有什么区别？

  > 

- GET和POST方法都是安全幂等的吗？

  > 安全：请求方法不会**破坏**服务器上的资源。
  >
  > 幂等：多次执行相同的操作，结果都是**相同**的。
  >
  > - GET是只读操作，因此是**安全且幂等**的，可以被浏览器**缓存**（彻底避免浏览器发请求）或被代理缓存。
  > - POST是根据请求的负载（报文主体）新增或修改数据，会修改服务器上的资源，且多次提交会多次创建或修改，因此是**不安全且不幂等**的。
  >
  > 以上只是RFC的规范，GET可以带body，可以实现新增或删除资源；POST的URL中可以有query string，可以实现查询数据的请求。

- HTTP缓存有哪些实现方式？

  > 对于一些具有重复性的HTTP请求，比如每次请求得到的数据都一样，可以把这对请求-响应的数据缓存在本地，下次直接读取本地的数据。分为**强制缓存**和**协商缓存**。

- 什么是强制缓存？

  > 只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在浏览器。状态码右边的size标识中是`from disk cache`或`from memory cache`的话就是使用了强制缓存。
  >
  > 强制缓存利用`Cache-control`(相对时间)或`Expires`(绝对时间)首部字段来标识资源缓存的有效期，都有的话则`Cache-control`的优先级更高，且它的选项更多、设置更精细，一般用它来实现强制缓存。
  >
  > 具体的流程：
  >
  > 1. 浏览器第一次请求时，服务器返回资源时在响应首部用Cache-Control设置过期时间。
  > 2. 浏览器再次请求该资源时，先**比较请求资源的时间是否超过Cache-control设置的过期时间**，没有则使用缓存，否则重新请求。
  > 3. 服务器再次收到请求后，更新Cache-Control的过期时间。

- 什么是协商缓存？

  > 与服务端协商后，通过协商结果判断是否使用本地缓存，若服务器返回`304`状态码，则使用缓存，否则重新请求。
  >
  > 协商缓存利用两个首部字段实现：
  >
  > - 请求首部`If-Modified-Since`，当资源过期后，浏览器发现响应首部有`Last-Modified`，则再次请求时把`If-Modified-Since`的值设为`Last-Modified`的值，服务器收到后发现请求首部有`If-Modified-Since`，则与被请求资源的最后修改时间进行对比，若最后修改时间较新，说明资源修改过，返回`200 OK`、新的修改时间和新资源；若最后修改时间较旧，说明资源无修改，返回空body和`304 Not Modified`。
  > - 响应首部`Last-Modified`表示响应资源最后的修改时间。
  >
  > 或者利用另外两个首部字段实现：
  >
  > - `If-None-Match`，当资源过期后，浏览器发现响应首部有`Etag`，则再次请求时把`If-None-Match`的值设为`Etag`的值，服务端收到请求后发现首部有`If-None-Match`则进行对比，如果资源未修改返回`304`，已修改返回`200`、新的`Etag`和新资源。
  > - `Etag`用来唯一标识响应的资源。

- 缓存补充

  > 若响应的首部中Etag和Last-Modified都有，则再次请求时会都带上，这时**Etag的优先级更高**，因为：
  >
  > - Etag基于标识实现，比基于时间实现的Last-Modified更准确，避免由于时间篡改导致的不可靠问题。
  > - If-Modified-Since能检查的粒度是秒级的，若文件在秒级以内被修改则无法发现。
  > - 一些服务器不能精确获取文件最后的修改时间。
  >
  > **协商缓存的字段都要配合强制缓存的Cache-control使用，只有强制缓存过期的时候，才能发起带有协商缓存字段的请求。**
  >
  > ![img](面试知识点.assets/http缓存.png)

- HTTP/1.1的优点有哪些？

  > - *简单*：报文格式基于报文首部和报文主体，首部字段也是键值对的形式，**易于理解**。
  > - *灵活且易于扩展*：HTTP协议中的要求没有被固定死，允许开发人员**自定义和扩充**；HTTP位于应用层，**下层可以随意变化**（如HTTPS就在TCP上加了SSL/TLS层；HTTP/3就把TCP改成了UDP）。
  > - *应用广泛且跨平台*

- HTTP/1.1的缺点有哪些？

  > - *无状态*：是一把双刃剑，**好处**是服务器**不需要额外的资源**记录状态信息，减轻CPU和内存负担；**坏处**是在完成有关联性的操作时会非常麻烦，因为服务器没有记忆能力。
  > - *明文传输*：是一把双刃剑，好处是方便阅读，为抓包调试带来了极大的便利性；坏处是信息很容易被窃取。
  > - *不安全*：**通信明文**，内容可能被窃听；**不验证通信方身份**，可能遭遇伪装；**无法证明报文完整性**，内容可能遭篡改。

- 什么是cookie和token？

  > - cookie：客户端第一次请求时，服务器会创建session并下发带有sessionID的cookie（响应头中设置`set-cookie: value[; expires=date][; domain=domain][; path=path][; secure]`），服务器把cookie保存在数据库或redis中，后续客户端请求服务器时带上这个cookie，服务器校验cookie来辨别用户。
  >
  > - jwt token：`header.claim/payload.signature`格式的字符串
  >
  >   - `header`固定为**{"alg":"加密算法","typ":"token类型"}**。
  >   - `claim/payload`中是用户信息和过期时间。
  >   - `signature`是把`header`和`claim/payload`分别base64编码后再加盐加密得到。
  >   - 以上三部分再分别经过base64编码后用`.`隔开，得到token字符串。
  >   - 第一次请求时由服务器下发，但服务器不保存，后续请求时客户端带上，服务器收到后先解码得到claim/payload中保存的用户信息，再根据这个信息加密生成signature，然后和客户端发来的signature比较，若一致则校验通过。
  >
  > - jwt token+refresh token：jwt token一旦签发则在过期时间内一直可用，服务端无法控制其过期时间或对其进行禁用。通过引入refresh token可用进行改进，refresh token需要由服务端保存在redis或数据库中。
  >
  >   ![img](面试知识点.assets/v2-8f29f24dd291ddf46abda5d5ab7bec6c_720w.webp)

- HTTP/1.1的性能如何？

  > HTTP/1.1通过以下方式提升性能
  >
  > - *长连接*，避免了重复建立和端口TCP连接造成的额外开销。
  > - *管道网络传输*，请求发出后不用等待响应就可以发送后续的请求出去，可以减少整体的响应时间，即**解决了请求的队头阻塞**。但服务端必须按照接收请求的顺序发送响应，因此**没有解决响应队头阻塞**。（实际上HTTP/1.1管道化技术不是默认开启，而且浏览器基本都没有支持）
  > - *队头阻塞*，请求-应答的模式加剧了性能问题，一个请求被阻塞后，后面的请求都收不到响应。

- HTTP与HTTPS有哪些区别？

  > - HTTPS在TCP和HTTP之间加入了**SSL/TLS层**，使报文能够加密传输。
  > - HTTPS在TCP三次握手之后还要进行**SSL/TLS握手**，才可进入加密报文传输。
  > - HTTP默认端口80，HTTPS默认端口**443**。
  > - HTTPS需要向CA机构申请**数字证书**，来保证服务器的身份是可信的。

- HTTPS使用什么方式解决了HTTP的哪些问题？

  > - *混合加密*：采用对称加密和非对称加密结合的混合加密方式，解决了被窃听的风险。（下图第5步只传输用key加密后的密文，key分别保存在客户端和服务端本地）
  >
  >   ![image-20221208173541438](面试知识点.assets/image-20221208173541438.png)
  >
  > - *摘要算法+数字签名*：用摘要算法（哈希函数）计算内容的哈希值，此值唯一且无法用值反推内容。对哈希值使用私钥加密得到数字签名后和内容一起发送，接收方用公钥解密，若能解出，则说明消息是来源于持有私钥的一方（保证消息的来源可靠性）。接收方用同样的哈希算法对内容进行计算，比较计算出的哈希值和用公钥解密出的哈希值，一致则说明内容未被篡改（保证消息的完整性）。
  >
  > - *数字证书*：如果公私钥被伪造并用伪造的私钥加密内容，接收方只能拿到伪造的公钥后解密，则会认为内容无误且来源可靠。因此服务器需要把真正的公钥注册到CA（数字证书认证机构），CA颁发数字证书给服务器。接收方收到服务器的证书后，用CA的公钥（内置在浏览器或OS中）确认证书是否是注册到CA的。解决了身份被伪造的风险。（详解见数字证书的流程？）

- HTTPS是如何建立连接的？其间交互了什么？

  > HTTPS需要先建立TCP连接，然后TLS握手后，才能建立通信安全的连接。
  >
  > 细节详见HTTPS RSA握手和HTTPS ECDHE握手。

- 数字证书的流程？

  > CA签发证书流程：
  >
  > 1. CA把服务器的公钥、用途、颁发者、有效时间等信息打包，再进行Hash计算得到Hash值。
  > 2. CA用自己的私钥将Hash值加密，生成Certificate Signature，即CA对证书做了签名。
  > 3. 将Certificate Signature添加在证书上颁发给服务器。
  >
  > 客户端校验证书流程：
  >
  > 1. 客户端使用同样的Hash算法获取证书的Hash值H1。
  > 2. 客户端使用浏览器或OS内置的CA公钥对收到的服务器证书的Certificate Signature进行解密，得到Hash值H2。
  > 3. 比较H1和H2，相同则证书可信赖。
  >
  > 实际过程中存在证书信任链，即CA颁发的证书并不是最终的证书。这是为了保证根证书的绝对安全性，将根证书隔离地越严格越好，否则根证书如果失守，整个信任链都会有问题。
  >
  > ![img](面试知识点.assets/证书链.png)

- HTTPS的应用数据是如何保证完整性的？

  > 通过**握手协议**和**记录协议**保证，位于下层的记录协议负责进行加密传输，而位于上层的握手协议则负责TLS四次握手，记录协议完成后，最终的报文数据将传递到TCP层进行传输。。详解见[理解SSL/TLS系列 (四) 记录协议](https://blog.csdn.net/zhanyiwp/article/details/105627799)

- HTTPS一定安全可靠吗？

  > 如果有假基站转发了全部信息给中间服务器，中间服务器与真正的服务器完成TLS握手，则中间服务器可以解密请求和响应的内容。不过证书仍然是伪造的，浏览器能识别出是非法的，就会提醒证书存在问题。所以，**HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全**。

- HTTP/2做了哪些优化？

  > - 头部压缩，使用HPACK算法在客户端和服务器同时维持一张头信息表，所有字段都在此表中，传输时只传输字段在表中的索引号。
  > - 报文采用二进制格式（头信息帧和数据帧）便于计算机解析。
  > - 并发传输，1个TCP连接中有多个Stream，1个Stream包含多个Message（请求或响应），1个Message包含多个帧（二进制的报文），每个Stream有独一无二的ID，不同Stream的帧可以乱序发送，接收端通过StreamID有序组装成HTTP消息。
  > - 服务器推送，和websocket的区别在于：websocket是主动推送，建立的是双向的实时通信；而http/2的推送只有在收到客户端的请求后才能推送。

- HTTP/3做了哪些优化？

  > 使用基于UDP的QUIC协议，无队头阻塞，更快地建立连接，连接迁移。

### HTTP/1.1优化

- 尽量避免发送HTTP请求：**缓存**技术。
- 在需要发送HTTP请求时，尽量减少请求次数：将**重定向交给代理服务器**完成以减少重定向的次数；把多个访问小文件的请求**合并成大请求**（如CSS精灵图）；延迟发送请求，当用户下**滑页面时再**向服务器获取接下来的资源。
- 减少服务器的HTTP响应的数据大小：**压缩**技术
  - 无损压缩：gzip，deflate，br（谷歌的Brotli），适用于文本、可执行文件。源代码等。
  - 有损压缩：舍弃次要的数据来提高压缩比，适用于多媒体文件。通过Accept字段的**q质量因子**告诉服务器期望的资源质量。`Accept: audio/*; q=0.2, audio/basic`。目前压缩比较高的是Google的**WebP**格式。

### HTTPS RSA握手



### HTTPS ECDHE握手

### HTTPS优化

### RPC

- RPC是一种调用方式，不是协议，一般基于TCP实现，也可基于HTTP、UDP实现，著名的实现方式有gRPC（底层使用HTTP/2）、thrift。
- RPC需要知道服务器的IP和端口才能建立连接，因此需要有中间服务来保存服务器名和IP信息，如consul、etcd、redis等。DNS也是服务发现的一种，如CoreDNS就是基于DNS实现的服务发现组件。
- 

### WebSocket

## TCP篇

## IP篇