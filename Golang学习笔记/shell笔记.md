# Shell笔记

## 简介

> Shell是一个用C语言编写的程序。业界所说的Shell通常是一种解释型语言，常用的解释器为Bourne Shell或Bourne Again Shell

- Bourne Shell：`/bin/sh`

- Bourne Again Shell：`/bin/bash`（大部分linux系统的默认Shell）

- 文件开头第一行：`#!/bin/bash`指定解释器

- 通过`./xxx.sh`（相对或绝对路径都行，要先给文件增加可执行权限）或`sh xxx.sh`（这种方式不需要在文件中指定解释器）来运行shell脚本

## 变量

### 定义变量

- 变量名和等号之间不能有空格
- 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头；中间不能有空格，可以使用下划线 **_**；不能使用标点符号；不能使用bash里的关键字
- 赋值
  - 直接赋值：`your_name="runoob.com"`
  - 用语句赋值：``for file in `ls /etc` ``或`for file in $(ls /etc)`

### 使用变量

- 使用一个定义过的变量，只要在变量名前面加美元符号即可：`echo $your_name`或`echo ${your_name}`
  - 变量名外面的花括号是可选的，加花括号是为了帮助解释器识别变量的边界，所以都加上
  - 在字符串中也能通过`$`来使用变量
- 已定义的变量，可以被重新定义

### 其他操作

- 只读变量：使用` readonly `命令可以将变量定义为只读变量，只读变量的值不能被改变
- 删除变量：使用 `unset `命令可以删除变量，变量被删除后不能被使用，`unset `命令不能删除只读变量
- 读取变量：`read` 命令从标准输入中读取一行，并把输入行的每个字段的值指定给 shell 变量

### 变量类型

运行shell时，会同时存在三种变量：

- 局部变量：在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量
- 环境变量：所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量
- shell变量：是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行

### 字符串

- 字符串可以用单引号，也可以用双引号，也可以不用引号

  - 单引号字符串：
    - 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的
    - 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用
  - 双引号字符串：
    - 双引号里可以有变量
    - 双引号里可以出现转义字符

- 拼接字符串：直接拼接，不需要加号

  ```shell
  your_name="runoob"
  # 使用双引号拼接
  greeting="hello, "$your_name" !"
  greeting_1="hello, ${your_name} !"
  echo $greeting  $greeting_1
  # 使用单引号拼接
  greeting_2='hello, '$your_name' !'
  greeting_3='hello, ${your_name} !'
  echo $greeting_2  $greeting_3
  
  # 输出结果为
  hello, runoob ! hello, runoob !
  hello, runoob ! hello, ${your_name} !
  ```

- 常用函数

  - 获取字符串长度：`echo ${#string}`
  - 提取字符串：`echo ${string:1:4}`（第一个字符的索引值为 0）
  - 查找字符串：``echo `expr index "$string" io` ``，查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)，变量两边的双引号必须加上

### 数组

- 用括号来表示数组，数组元素用"空格"符号分割开，`array_name=(value0 value1 value2 value3)`
- 数组元素的下标由0开始，获取数组中的元素要利用下标，下标可以是整数或算术表达式，`array_name[0]=value0`
- 读取数组元素值的一般格式是：`${数组名[下标]}`
- 获取数组中的所有元素：`echo ${array_name[*]}`或`echo ${array_name[@]}`
- 获取数组长度：`${#my_array[*]}`或`echo ${array_name[@]}`

### 注释

- 以`#`开头

- 多行注释还可以使用以下格式，EOF也可以换成其他符号

  ```shell
  :<<EOF
  注释内容...
  注释内容...
  注释内容...
  EOF
  ```

## 传递参数

- 在执行 Shell 脚本时向脚本传递参数，脚本内获取参数的格式为：`$n`，0为文件名，1为第一个参数，以此类推

- 其他用法（前三个常用）：

  | 参数处理 | 说明                                                         |
  | -------- | ------------------------------------------------------------ |
  | $#       | 传递到脚本的参数个数                                         |
  | $*       | 以一个单字符串显示所有向脚本传递的参数（从1开始）            |
  | $$       | 脚本运行的当前进程ID号                                       |
  | $!       | 后台运行的最后一个进程的ID号                                 |
  | $@       | 效果与`$*`相同。只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 " * " 等价于 "1 2 3"（传递了一个参数），而 "@" 等价于 "1" "2" "3"（传递了三个参数） |
  | $-       | 显示Shell使用的当前选项，与[set命令](https://www.runoob.com/linux/linux-comm-set.html)功能相同。 |
  | $?       | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 |

## 运算符

> 原生bash不支持简单的数学运算，可以awk或expr来实现，expr 最常用
>
> `expr $a + $b`的效果和`$[a+b]`一样（a+b的两边没有空格也能正常运行）

bash运算符包括：

- 算数运算符
- 关系运算符
- 布尔运算符
- 字符串运算符
- 文件测试运算符

两点注意：

- 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2
- 完整的表达式要被 ```` `` 包含
- 运算结果为bool类型的运算符，在if中使用才会起作用，且中括号中的表达式两边必须有空格

### 算数运算符

> 假定变量 a 为 10，变量 b 为 20

| 运算符 | 说明                                          | 举例                          |
| :----- | :-------------------------------------------- | :---------------------------- |
| +      | 加法                                          | `expr $a + $b` 结果为 30。    |
| -      | 减法                                          | `expr $a - $b` 结果为 -10。   |
| *      | 乘法                                          | `expr $a \* $b` 结果为  200。 |
| /      | 除法                                          | `expr $b / $a` 结果为 2。     |
| %      | 取余                                          | `expr $b % $a` 结果为 0。     |
| =      | 赋值                                          | a=$b 将把变量 b 的值赋给 a。  |
| ==     | 相等。用于比较两个数字，相同则返回 true。     | [ \$a == \$ b ] 返回 false。  |
| !=     | 不相等。用于比较两个数字，不相同则返回 true。 | [ \$a != \$b ] 返回 true。    |

### 关系运算符

> 假定变量 a 为 10，变量 b 为 20

| 运算符 | 说明                                                  | 举例                        |
| :----- | :---------------------------------------------------- | :-------------------------- |
| -eq    | 检测两个数是否相等，相等返回 true。                   | [ \$a -eq $b ] 返回 false。 |
| -ne    | 检测两个数是否不相等，不相等返回 true。               | [ \$a -ne $b ] 返回 true。  |
| -gt    | 检测左边的数是否大于右边的，如果是，则返回 true。     | [ \$a -gt $b ] 返回 false。 |
| -lt    | 检测左边的数是否小于右边的，如果是，则返回 true。     | [ \$a -lt $b ] 返回 true。  |
| -ge    | 检测左边的数是否大于等于右边的，如果是，则返回 true。 | [ \$a -ge $b ] 返回 false。 |
| -le    | 检测左边的数是否小于等于右边的，如果是，则返回 true。 | [ \$a -le $b ] 返回 true。  |

### 布尔运算符

> 假定变量 a 为 10，变量 b 为 20

| 运算符 | 说明                                                | 举例                                      |
| :----- | :-------------------------------------------------- | :---------------------------------------- |
| !      | 非运算，表达式为 true 则返回 false，否则返回 true。 | [ ! false ] 返回 true。                   |
| -o     | 或运算，有一个表达式为 true 则返回 true。           | [ \$a -lt 20 -o $b -gt 100 ] 返回 true。  |
| -a     | 与运算，两个表达式都为 true 才返回 true。           | [ \$a -lt 20 -a $b -gt 100 ] 返回 false。 |

### 逻辑运算符

> 假定变量 a 为 10，变量 b 为 20

| 运算符 | 说明       | 举例                                        |
| :----- | :--------- | :------------------------------------------ |
| &&     | 逻辑的 AND | [[ \$a -lt 100 && $b -gt 100 ]] 返回 false  |
| \|\|   | 逻辑的 OR  | [[ \$a -lt 100 \|\| $b -gt 100 ]] 返回 true |

### 字符串运算符

> 假定变量 a 为 "abc"，变量 b 为 "efg"

| 运算符 | 说明                                         | 举例                     |
| :----- | :------------------------------------------- | :----------------------- |
| =      | 检测两个字符串是否相等，相等返回 true。      | [ \$a = $b ] 返回 false。 |
| !=     | 检测两个字符串是否不相等，不相等返回 true。  | [ \$a != $b ] 返回 true。 |
| -z     | 检测字符串长度是否为0，为0返回 true。        | [ -z $a ] 返回 false。   |
| -n     | 检测字符串长度是否不为 0，不为 0 返回 true。 | [ -n "$a" ] 返回 true。  |
| \$     |检测字符串是否为空，不为空返回 true。|[ $a ] 返回 true|

### 文件测试运算符

> 假定变量 a 为 10，变量 b 为 20

| 操作符  | 说明                                                         | 举例                      |
| :------ | :----------------------------------------------------------- | :------------------------ |
| -b file | 检测文件是否是块设备文件，如果是，则返回 true。              | [ -b $file ] 返回 false。 |
| -c file | 检测文件是否是字符设备文件，如果是，则返回 true。            | [ -c $file ] 返回 false。 |
| -d file | 检测文件是否是目录，如果是，则返回 true。                    | [ -d $file ] 返回 false。 |
| -f file | 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 | [ -f $file ] 返回 true。  |
| -g file | 检测文件是否设置了 SGID 位，如果是，则返回 true。            | [ -g $file ] 返回 false。 |
| -k file | 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。  | [ -k $file ] 返回 false。 |
| -p file | 检测文件是否是有名管道，如果是，则返回 true。                | [ -p $file ] 返回 false。 |
| -u file | 检测文件是否设置了 SUID 位，如果是，则返回 true。            | [ -u $file ] 返回 false。 |
| -r file | 检测文件是否可读，如果是，则返回 true。                      | [ -r $file ] 返回 true。  |
| -w file | 检测文件是否可写，如果是，则返回 true。                      | [ -w $file ] 返回 true。  |
| -x file | 检测文件是否可执行，如果是，则返回 true。                    | [ -x $file ] 返回 true。  |
| -s file | 检测文件是否为空（文件大小是否大于0），不为空返回 true。     | [ -s $file ] 返回 true。  |
| -e file | 检测文件（包括目录）是否存在，如果是，则返回 true。          | [ -e $file ] 返回 true。  |

## Shell命令

### echo

- 双引号：可以显示转义字符（`\"`会只显示`"`)，可以使用变量；单引号：原样输出；反引号：反引号中命令的执行结果（和直接执行命令的效果一样）
- 输出结果定向至文件：`echo "It is a test" > myfile`
- 开启转义：`echo -e "OK! \n"`，`\n`换行，`\c`不换行，`echo "OK \n"`的话会把`\n`原样输出

### printf

- `printf`由POSIX标准所定义，因此使用printf的脚本比使用echo移植性好
- `printf format-string [arguments...]`
  - `%s` `%c` `%d` `%f` 都是格式替代符，`％s`输出一个字符串，`％d`整型输出，`％c` 输出一个字符，`％f` 输出实数，以小数形式输出。
  - `%-10s` 指一个宽度为 10 个字符（`-` 表示左对齐，没有则表示右对齐），任何字符都会被显示在 10 个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。
  - `%-4.2f` 指格式化为小数，其中 `.2` 指保留2位小数。

### test

> test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试

## 流程控制

> Shell的流程控制不可为空，即某个分支中不能没有执行语句

### if else

> if else 语句经常与 test 命令结合使用

```shell
# if
if condition
then
    command1 
    command2
    ...
    commandN 
fi
```

```shell
#if else
if condition
then
    command1 
    command2
    ...
    commandN
else
    command
fi
```

```shell
# if else-if else
if condition1
then
    command1
elif condition2 
then 
    command2
else
    commandN
fi
```

### for循环

> in列表是可选的，如果不用它，for循环使用命令行的位置参数。in 列表可以包含替换、字符串和文件名。

```shell
for var in item1 item2 ... itemN
do
    command1
    command2
    ...
    commandN
done
```

```shell
# 顺序输出字符串中的字符
for str in This is a string
do
    echo $str
done

# 输出结果
This
is
a
string
```

### while循环

```shell
while condition
do
    command
done
```

```shell
# 用let控制while的退出，不需要加上$来表示变量
int=1
while(( $int<=5 ))	# 或者[ $int -le 5 ]
do
    echo $int
    let "int++"
done
```

### 无限循环

```shell
#1
while :
do
    command
done

#2
while true
do
    command
done

#3
for (( ; ; ))
```

### until循环

> until 循环与 while 循环在处理方式上刚好相反，一般 while 循环优于 until 循环

```shell
until condition
do
    command
done
```

### case..esac

> 每个 case 分支用右圆括号开始，用两个分号 **;;** 表示 break，esac（就是 case 反过来）作为结束标记。

```shell
case val in
condition1)
    command1
    command2
    ...
    commandN
    ;;
condition1)
    command1
    command2
    ...
    commandN
    ;;
esac
```

```shell
read site
case "$site" in
   "runoob") echo "菜鸟教程"
   ;;
   "google") echo "Google 搜索"
   ;;
   "taobao") echo "淘宝网"
   ;;
esac
```

### 跳出流程控制

- `break`：允许跳出所有循环（终止执行后面的所有循环）
- `continue`：仅仅跳出当前循环

## 函数

### 函数定义

```shell
# shell中函数的定义格式
[ function ] funname()
{
    action;
    [return int;]
}
```

- 可以`function fun()`定义，也可以直接`fun()` 定义
- 参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)
- 函数返回值在调用该函数后通过`$?`来获得
- 所有函数在使用前必须定义，调用函数仅使用其函数名即可

### 函数参数

- 定义函数时不需要参数，调用函数时直接传递参数即可

- 在函数体内部，通过`$n`(n>0)的形式来获取参数的值；当n>=10时，需要使用${n}来获取参数

  | 参数处理 | 说明                                                         |
  | :------- | :----------------------------------------------------------- |
  | $#       | 传递到脚本或函数的参数个数                                   |
  | $*       | 以一个单字符串显示所有向脚本传递的参数                       |
  | $$       | 脚本运行的当前进程ID号                                       |
  | $!       | 后台运行的最后一个进程的ID号                                 |
  | $@       | 与$*相同，但是使用时加引号，并在引号中返回每个参数。         |
  | $-       | 显示Shell使用的当前选项，与set命令功能相同。                 |
  | $?       | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 |

## 重定向

> 需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR

| 命令            | 说明                                               |
| :-------------- | :------------------------------------------------- |
| command > file  | 将输出重定向到 file。                              |
| command < file  | 将输入重定向到 file。                              |
| command >> file | 将输出以追加的方式重定向到 file。                  |
| n > file        | 将文件描述符为 n 的文件重定向到 file。             |
| n >> file       | 将文件描述符为 n 的文件以追加的方式重定向到 file。 |
| n >& m          | 将输出文件 m 和 n 合并。                           |
| n <& m          | 将输入文件 m 和 n 合并。                           |
| << tag          | 将开始标记 tag 和结束标记 tag 之间的内容作为输入。 |

## 文件包含

> 被包含的文件不需要可执行权限。文件被包含后，包含的文件可以使用被包含文件的所有资源

```shell
# filename可以是相对路径或绝对路径
. filename
# 或
source filename
```

